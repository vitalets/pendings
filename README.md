# Pendings

[![Build Status](https://travis-ci.org/vitalets/pendings.svg?branch=master)](https://travis-ci.org/vitalets/pendings)
[![npm](https://img.shields.io/npm/v/pendings.svg)](https://www.npmjs.com/package/pendings)
[![license](https://img.shields.io/npm/l/pendings.svg)](https://www.npmjs.com/package/pendings)

> Better control of pending [Promises](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise)

*Pendings* is a library for control of pending promises. 
It manages `resolve` / `reject` callbacks and provides convenient access to them for promise fulfillment.

## Installation
```bash
npm install pendings --save
```

## Usage (single promise)
Typical situation with promises in event-based code:
```js
class Foo {
    constructor() {
      this.promise = null;
      this.resolve = null;
      this.reject = null;
    }
    asyncRequest() {
        if (this.promise) { // if promise already exists - return it
            return this.promise;
        }
        this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
            this.send();
        });
        return this.promise;
    }
    onSuccess(data) {
        this.resolve(data);
    }
}    
```    
[Pending](#pending) class allows to do it simpler:   
```js
const Pending = require('pendings').Pending;

class Foo {
    constructor() {
        this.pending = new Pending();
    }
    asyncRequest() { 
        return this.pending.call(() => this.send());
    }
    onSuccess(data) {
        this.pending.resolve(data);
    }
}
```
## Usage (list of promises)
[Pendings](#pendings) class is useful for dynamic list of promises. 
Each promise can automatically get unique `id` and can be fulfilled later by that id. 
After fulfillment promise is removed from list.
```js
const Pendings = require('pendings');

class Foo {
    constructor() {
        this.pendings = new Pendings();
    }    

    asyncRequest() { 
        return this.pendings.add(id => {
            this.send({id, foo: 'bar'}); // mark request with unique `id` generated by Pendings
        });
    }
    
    onSuccess(data) {
        this.pendings.resolve(data.id, data); // resolve by `id`
    }
    
    onError(data) {
        this.pendings.reject(data.id, data); // reject by `id`
    }
}
```

## API

## Classes

<dl>
<dt><a href="#Pending">Pending</a></dt>
<dd></dd>
<dt><a href="#Pendings">Pendings</a></dt>
<dd></dd>
<dt><a href="#TimeoutError">TimeoutError</a></dt>
<dd></dd>
</dl>

<a name="Pending"></a>

## Pending
**Kind**: global class  

* [Pending](#Pending)
    * [new Pending()](#new_Pending_new)
    * [.promise](#Pending+promise) ⇒ <code>Promise</code>
    * [.isResolved](#Pending+isResolved) ⇒ <code>Boolean</code>
    * [.isRejected](#Pending+isRejected) ⇒ <code>Boolean</code>
    * [.isFulfilled](#Pending+isFulfilled) ⇒ <code>Boolean</code>
    * [.onFulfilled](#Pending+onFulfilled)
    * [.call(fn, [timeout])](#Pending+call) ⇒ <code>Promise</code>
    * [.resolve([value])](#Pending+resolve)
    * [.reject([reason])](#Pending+reject)
    * [.fulfill([value], [reason])](#Pending+fulfill)
    * [.reset()](#Pending+reset)

<a name="new_Pending_new"></a>

### new Pending()
Creates instance of single pending promise. It holds `resolve / reject` callbacks for future fulfillment.

<a name="Pending+promise"></a>

### pending.promise ⇒ <code>Promise</code>
Returns promise itself.

**Kind**: instance property of [<code>Pending</code>](#Pending)  
<a name="Pending+isResolved"></a>

### pending.isResolved ⇒ <code>Boolean</code>
Returns true if promise resolved.

**Kind**: instance property of [<code>Pending</code>](#Pending)  
<a name="Pending+isRejected"></a>

### pending.isRejected ⇒ <code>Boolean</code>
Returns true if promise rejected.

**Kind**: instance property of [<code>Pending</code>](#Pending)  
<a name="Pending+isFulfilled"></a>

### pending.isFulfilled ⇒ <code>Boolean</code>
Returns true if promise fulfilled (resolved or rejected).

**Kind**: instance property of [<code>Pending</code>](#Pending)  
<a name="Pending+onFulfilled"></a>

### pending.onFulfilled
Callback called when promise is fulfilled (resolved or rejected).

**Kind**: instance property of [<code>Pending</code>](#Pending)  

| Param | Type |
| --- | --- |
| fn | <code>function</code> | 

<a name="Pending+call"></a>

### pending.call(fn, [timeout]) ⇒ <code>Promise</code>
For the first time this method calls `fn` and returns new promise. Also holds `resolve` / `reject` callbacks
to allow fulfill promise via `pending.resolve()` and `pending.reject()`. All subsequent calls of `.call(fn)`
will return the same promise, which can be still pending or already fulfilled.
To reset this behavior use `.reset()`. If `timeout` is specified, the promise will be automatically rejected
after `timeout` milliseconds with `PendingTimeoutError`.

**Kind**: instance method of [<code>Pending</code>](#Pending)  

| Param | Type | Default |
| --- | --- | --- |
| fn | <code>function</code> |  | 
| [timeout] | <code>Number</code> | <code>0</code> | 

<a name="Pending+resolve"></a>

### pending.resolve([value])
Resolves pending promise with specified `value`.

**Kind**: instance method of [<code>Pending</code>](#Pending)  

| Param | Type |
| --- | --- |
| [value] | <code>\*</code> | 

<a name="Pending+reject"></a>

### pending.reject([reason])
Rejects pending promise with specified `reason`.

**Kind**: instance method of [<code>Pending</code>](#Pending)  

| Param | Type |
| --- | --- |
| [reason] | <code>\*</code> | 

<a name="Pending+fulfill"></a>

### pending.fulfill([value], [reason])
Helper method: rejects if `reason` is truthy, otherwise resolves with `value`.

**Kind**: instance method of [<code>Pending</code>](#Pending)  

| Param | Type |
| --- | --- |
| [value] | <code>\*</code> | 
| [reason] | <code>\*</code> | 

<a name="Pending+reset"></a>

### pending.reset()
Resets to initial state.

**Kind**: instance method of [<code>Pending</code>](#Pending)  
<a name="Pendings"></a>

## Pendings
**Kind**: global class  

* [Pendings](#Pendings)
    * [new Pendings([options])](#new_Pendings_new)
    * [.add(fn, [options])](#Pendings+add) ⇒ <code>Promise</code>
    * [.set(id, fn, [options])](#Pendings+set) ⇒ <code>Promise</code>
    * [.has(id)](#Pendings+has) ⇒ <code>Boolean</code>
    * [.resolve(id, [value])](#Pendings+resolve)
    * [.reject(id, [reason])](#Pendings+reject)
    * [.fulfill(id, [value], [reason])](#Pendings+fulfill)
    * [.tryResolve(id, [value])](#Pendings+tryResolve)
    * [.tryReject(id, [reason])](#Pendings+tryReject)
    * [.tryFulfill(id, [value], [reason])](#Pendings+tryFulfill)
    * [.rejectAll([reason])](#Pendings+rejectAll)
    * [.generateId()](#Pendings+generateId) ⇒ <code>String</code>

<a name="new_Pendings_new"></a>

### new Pendings([options])
Creates dynamic list of promises. When each promise if fulfilled it is remove from list.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [options] | <code>Object</code> |  |  |
| [options.idPrefix] | <code>String</code> | <code>&#x27;&#x27;</code> | prefix for generated IDs |
| [options.timeout] | <code>Number</code> | <code>0</code> | default timeout for all promises |

<a name="Pendings+add"></a>

### pendings.add(fn, [options]) ⇒ <code>Promise</code>
Calls `fn` and returns new promise. `fn` gets generated unique `id` as parameter.

**Kind**: instance method of [<code>Pendings</code>](#Pendings)  

| Param | Type | Description |
| --- | --- | --- |
| fn | <code>function</code> |  |
| [options] | <code>Object</code> |  |
| [options.timeout] | <code>Number</code> | custom timeout for particular promise |

<a name="Pendings+set"></a>

### pendings.set(id, fn, [options]) ⇒ <code>Promise</code>
Calls `fn` and returns new promise with specified `id`.
If promise with such `id` already pending - it will be returned.

**Kind**: instance method of [<code>Pendings</code>](#Pendings)  

| Param | Type | Description |
| --- | --- | --- |
| id | <code>String</code> |  |
| fn | <code>function</code> |  |
| [options] | <code>Object</code> |  |
| [options.timeout] | <code>Number</code> | custom timeout for particular promise |

<a name="Pendings+has"></a>

### pendings.has(id) ⇒ <code>Boolean</code>
Checks if promise with specified `id` is pending.

**Kind**: instance method of [<code>Pendings</code>](#Pendings)  

| Param | Type |
| --- | --- |
| id | <code>String</code> | 

<a name="Pendings+resolve"></a>

### pendings.resolve(id, [value])
Resolves pending promise by `id` with specified `value`.
Throws if promise does not exist or is already fulfilled.

**Kind**: instance method of [<code>Pendings</code>](#Pendings)  

| Param | Type |
| --- | --- |
| id | <code>String</code> | 
| [value] | <code>\*</code> | 

<a name="Pendings+reject"></a>

### pendings.reject(id, [reason])
Rejects pending promise by `id` with specified `reason`.
Throws if promise does not exist or is already fulfilled.

**Kind**: instance method of [<code>Pendings</code>](#Pendings)  

| Param | Type |
| --- | --- |
| id | <code>String</code> | 
| [reason] | <code>\*</code> | 

<a name="Pendings+fulfill"></a>

### pendings.fulfill(id, [value], [reason])
Rejects pending promise by `id` if `reason` is truthy, otherwise resolves with `value`.
Throws if promise does not exist or is already fulfilled.

**Kind**: instance method of [<code>Pendings</code>](#Pendings)  

| Param | Type |
| --- | --- |
| id | <code>String</code> | 
| [value] | <code>\*</code> | 
| [reason] | <code>\*</code> | 

<a name="Pendings+tryResolve"></a>

### pendings.tryResolve(id, [value])
Resolves pending promise by `id` with specified `value` if it exists.

**Kind**: instance method of [<code>Pendings</code>](#Pendings)  

| Param | Type |
| --- | --- |
| id | <code>String</code> | 
| [value] | <code>\*</code> | 

<a name="Pendings+tryReject"></a>

### pendings.tryReject(id, [reason])
Rejects pending promise by `id` with specified `reason` if it exists.

**Kind**: instance method of [<code>Pendings</code>](#Pendings)  

| Param | Type |
| --- | --- |
| id | <code>String</code> | 
| [reason] | <code>\*</code> | 

<a name="Pendings+tryFulfill"></a>

### pendings.tryFulfill(id, [value], [reason])
Rejects pending promise by `id` if `reason` is truthy, otherwise resolves with `value`.

**Kind**: instance method of [<code>Pendings</code>](#Pendings)  

| Param | Type |
| --- | --- |
| id | <code>String</code> | 
| [value] | <code>\*</code> | 
| [reason] | <code>\*</code> | 

<a name="Pendings+rejectAll"></a>

### pendings.rejectAll([reason])
Rejects all pending promises with specified `reason`. Useful for cleanup.

**Kind**: instance method of [<code>Pendings</code>](#Pendings)  

| Param | Type |
| --- | --- |
| [reason] | <code>\*</code> | 

<a name="Pendings+generateId"></a>

### pendings.generateId() ⇒ <code>String</code>
Generates unique ID. Can be overwritten.

**Kind**: instance method of [<code>Pendings</code>](#Pendings)  
<a name="TimeoutError"></a>

## TimeoutError
**Kind**: global class  
<a name="new_TimeoutError_new"></a>

### new TimeoutError(timeout)
Timeout error for pending promise.


| Param | Type |
| --- | --- |
| timeout | <code>Number</code> | 


## License
MIT @ [Vitaliy Potapov](https://github.com/vitalets)
